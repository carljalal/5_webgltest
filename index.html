<html>
<head>
    <style>
        body {margin:0px}
    </style>
</head>
<body>
<script src = "three.js"></script>
<script src = ""></script>
<script>

//import { FontLoader } from 'https://threejs.org/examples/jsm/loaders/FontLoader.js';		// to step 11
//import { TextGeometry } from 'https://threejs.org/examples/jsm/geometries/TextGeometry.js'; // to step 11

globals = {}
globals.cameramode_label = "camera mode (press enter for command mode)"
globals.typingmode_label = "typing mode: "




//query = document.createElement("input");
//query.setAttribute("type","textarea");
//document.body.append(query);
//query.setAttribute("width","1000")

div = document.createElement("div");
div.setAttribute("style","font-family:verdana;font-size:24px;color:yellow");
div.innerHTML = globals.cameramode_label;
document.body.append(div);

document.body.style.backgroundColor = "#000000"
        

const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / (window.innerHeight - 50) );
const scene = new THREE.Scene();
        
        
const renderer = new THREE.WebGLRenderer({antialias:true})
renderer.setSize(window.innerWidth,window.innerHeight - 50)
document.body.appendChild(renderer.domElement)

const ambientlight = new THREE.AmbientLight(0xffffff,0.1)
const pointlight = new THREE.PointLight(0xffffff,0.4)
pointlight.position.set(0,2,0)

const boxgeometry = new THREE.SphereGeometry(1,30,30)
const material = new THREE.MeshPhongMaterial({color:0xffaa11,flatShading:false,opacity:0.9,transparent:true,side: THREE.DoubleSide})
const mesh = new THREE.Mesh(boxgeometry,material)
mesh.castShadow = true;
mesh.position.set(-3,0,-3)

scene.add(ambientlight, pointlight)
scene.add(mesh)

const planegeometry = new THREE.PlaneGeometry(20,20)
const redmaterial = new THREE.MeshPhongMaterial({color:0xff6532,flatShading:false,side: THREE.DoubleSide})
mesh_grid = new THREE.Mesh(planegeometry,redmaterial)
mesh_grid.position.set(0,-1,1)
mesh_grid.rotation.x=Math.PI/2

const wireframe = new THREE.WireframeGeometry(planegeometry);
const lines = new THREE.LineSegments(wireframe)
lines.position.set(0,-1,1)
lines.rotation.x=Math.PI/2

const gridhelper = new THREE.GridHelper(20,20);
gridhelper.position.set(0,-1,1)

scene.add(gridhelper)

//scene.add(lines)

scene.add(mesh_grid)

scene.background = new THREE.Color(0xffffff);
scene.fog = new THREE.Fog(0xffffff,250,1400);

//camera.position.z = 5


// 1001fonts
// fonts.google.com
// gero3.github.io/facetype.js/
/*
const loader = new THREE.FontLoader();
loader.load('./Joan_Regular.json', (font) => {
    const geometry = new THREE.TextGeometry("Hi.\nHow are you?",
    {
        font: font,
        size: 6,
        height: 2
    })

    const textmesh = new THREE.Mesh(geometry, [
        new THREE.MeshPhongMaterial({color:0xffaa44}),
        new THREE.MeshPhongMaterial({color:0xffa44})
    ])

    textmesh.castShadow = true;
    textmesh.position.set(0,0,0);

    scene.add()
})
*/


renderer.render(scene, camera);

x=0
y=0
z=0
a=0;b=0;c=0;
speed = 0.5;
rotspeed = Math.PI /8;
listentyping = false;
listencamera = true;
typedword = "";

camera.position.set(x,y,z);
camera.lookAt(x-Math.sin(b),y+Math.sin(a),z-Math.cos(b));

updaterender = () => {
    camera.position.set(x,y,z);
    camera.lookAt(x-Math.sin(b),  y+Math.sin(a),   z-Math.cos(b));
    // +sin(a) to both for y upside down??
    renderer.render(scene, camera);
}

enter_handler = () => {
    if(listencamera == true) {
        listencamera = false;
        listentyping = true;
        div.innerHTML = globals.typingmode_label;
        return;
    }
    if(listentyping == true){
        execute_command();
        typedword = "";
        div.innerHTML = globals.cameramode_label;
        listentyping = false;
        listencamera = true;
    }
}

// remove grid element search here
remove_grid_element = () => {

}

// have remove function
// display coordinates of camera
// option to display of list of objects in scene

// the sadness of leaving
// the joy of returning
// the appreciation of staying
// the curiosity of being alone
// responsiveness
get_parameters = () =>
{
    parameters = {};
    words = typedword.split(" ");
    parameters.geometry = words[0];
    words.length > 1? parameters.gridx = parseInt(words[1]) : parameters.gridx = 0;
    words.length > 2? parameters.gridy = parseInt(words[2]) : parameters.gridy = 0;
    words.length > 3? parameters.gridz = parseInt(words[3]) : parameters.gridz = 0;
    words.length > 4? parameters.width = parseInt(words[4]) : parameters.width = 1;
    words.length > 5? parameters.height = parseInt(words[5]) : parameters.height = 1;
    words.length > 6? parameters.depth = parseInt(words[6]) : parameters.depth = 1;
    words.length > 7? parameters.color = words[7] : parameters.color = "white";
    words.length > 8? parameters.intensity = words[8] : parameters.intensity = 1.0;
    words.length > 9? parameters.text = words[9] : parameters.text = "";
    words.length > 10? parameters.text = words[10] : parameters.rotationx = 0.0;
    words.length > 11? parameters.text = words[11] : parameters.rotationy = 0.0;
    words.length > 12? parameters.text = words[12] : parameters.rotationz = 0.0;
    return parameters;
}

draw_light = (parameters) => {
    const pointlight = new THREE.PointLight(parameters.color,1.0);
    pointlight.position.set(parameters.gridx,parameters.gridy,parameters.gridz);
    scene.add(pointlight);
}

draw_box = (parameters) => {
    propmaterial = new THREE.MeshPhongMaterial({color:parameters.color,side:THREE.DoubleSide});
    propgeometry = new THREE.BoxGeometry(parameters.width,parameters.height,parameters.depth);
    propmesh = new THREE.Mesh(propgeometry,propmaterial);
    propmesh.position.set(parameters.gridx,parameters.gridy,parameters.gridz);
    propmesh.rotation.set(parameters.rotationx,parameters.rotationy,parameters.rotationz);
    scene.add(propmesh);
}

draw_text = (parameters) => {

}

draw_plane = (parameters) => {
    propmaterial = new THREE.MeshPhongMaterial({color:parameters.color,side:THREE.DoubleSide});
    propgeometry = new THREE.PlaneGeometry(parameters.width,parameters.height);
    propmesh = new THREE.Mesh(propgeometry,propmaterial);
    propmesh.position.set(parameters.gridx,parameters.gridy,parameters.gridz);
    propmesh.rotation.set(parameters.rotationx,parameters.rotationy,parameters.rotationz);
    scene.add(propmesh);
}

draw_torus = (parameters) => {
    propmaterial = new THREE.MeshPhongMaterial({color:parameters.color,side:THREE.DoubleSide});
    propgeometry = new THREE.TorusGeometry(arameters.width,parameters.height,parameters.depth,50);
    propmesh = new THREE.Mesh(propgeometry,propmaterial);
    propmesh.position.set(parameters.gridx,parameters.gridy,parameters.gridz);
    propmesh.rotation.set(parameters.rotationx,parameters.rotationy,parameters.rotationz);
    scene.add(propmesh);
}

draw_sphere = (parameters) => {
    propmaterial = new THREE.MeshPhongMaterial({color:parameters.color,side:THREE.DoubleSide});
    propgeometry = new THREE.TorusGeometry(arameters.width,parameters.height,parameters.depth,50);
    propmesh = new THREE.Mesh(propgeometry,propmaterial);
    propmesh.position.set(parameters.gridx,parameters.gridy,parameters.gridz);
    propmesh.rotation.set(parameters.rotationx,parameters.rotationy,parameters.rotationz);
    scene.add(propmesh);
}

execute_command = () =>{
    // get parameters
    parameters = get_parameters();

    if (parameters.geometry == "light"){
        draw_light(parameters);
    }
    if (parameters.geometry == "box"){
        draw_box(parameters);
    }
    if (parameters.geometry == "plane"){
        draw_plane(parameters);
    }
    if (parameters.geometry == "torus"){
        draw_light(parameters);
    }
    if (parameters.geometry == "text"){
        draw_text(parameters);
    }
    if (parameters.geometry == "sphere"){
        draw_sphere(parameters);
    }
    // cylinder
    // cone
    // tube

 

}

camerahandler = (event) =>{
    // position keys
    if(event.key=="w"){
        z-=speed*Math.cos(b);
        y-=speed*Math.sin(-a);
        x-=speed*Math.sin(b);
    }
    if(event.key=="s"){
        z+=speed*Math.cos(b);
        y+=speed*Math.sin(-a);
        x+=speed*Math.sin(b);
    }
    if(event.key=="a"){
        z-=speed*Math.sin(-b);
        y-=speed*Math.sin(c);
        x-=speed*Math.cos(-b);
    }
    if(event.key=="d"){
        z+=speed*Math.sin(-b);
        y+=speed*Math.sin(c);
        x+=speed*Math.cos(-b);
    }
    if(event.key=="f"){
        //z-=speed*Math.sin(b);
        //y-=speed*Math.cos(c);
        //x-=speed*Math.sin(b);
        y-=speed;
    }
    if(event.key=="r"){
        y+=speed;
        //z+=speed*Math.sin(b);
        //y+=speed*Math.cos(c);
        //x+=speed*Math.sin(b);
    }
    // rotation keys
    if(event.key=="g"){
        a-=rotspeed
    }
    if(event.key=="t"){
        a+=rotspeed
    }
    if(event.key=="e"){
        b-=rotspeed
    }
    if(event.key=="q"){
        b+=rotspeed
    }
    if(event.key=="z"){
        c-=rotspeed
    }
    if(event.key=="c"){
        c+=rotspeed   
    }
    updaterender();
}


listentypinghandler = (event) =>{
    if(event.key == "Enter") return;

    if(event.key == "Backspace"){
        typedword = typedword.substring(0,typedword.length - 1);
    }

    if(event.key != "Backspace"){
        typedword += event.key;
    }

    div.innerHTML = "typing mode: " + typedword + "|";
}

window.addEventListener("keydown",(event)=>{
    if(event.key == "Enter"){
        enter_handler();
    }
    if(listencamera == true) {
        camerahandler(event);
    }
    if(listentyping == true){
        listentypinghandler(event);
    }
})
</script>
</body>
</html>
